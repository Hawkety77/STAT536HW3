Leather = 1)
)
install.packages("boot")
library(boot)
cv_result <- cv.glm(cc, kbb.lm, K = 10)  # K is the number of folds, e.g., 10-fold CV
View(cc)
cv_result <- cv.glm(kbb, kbb.lm, K = 10)  # K is the number of folds, e.g., 10-fold CV
cv_result$delta[1]
cv_result <- cv.glm(test1, kbb.lm, K = 10)  # K is the number of folds, e.g., 10-fold CV
cv_result <- cv.glm(kbb, test1, K = 10)  # K is the number of folds, e.g., 10-fold CV
cv_result$delta[1]
cost_function <- function(actual, predicted) {
mean((actual - predicted)^2)
}
?cv.glm
cost_function <- function(actual, predicted) {
mean((actual - predicted)^2)
}
cv_result <- cv.glm(kbb, test1, cost_function = cost_function, K = 10)  # K is the number of folds, e.g., 10-fold CV
cv_result <- cv.glm(kbb, test1, cost = cost_function, K = 10)  # K is the number of folds, e.g., 10-fold CV
cv_result$delta[1]
View(cv_result)
kbb.glm <- glm(Price ~ Mileage + Make + Type + Liter + Cylinder + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
cv_result$delta[1]
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Type + Liter + Cylinder + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
library(boot)
kbb.glm <- glm(Price ~ Mileage + Make + Type + Liter + Cylinder + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Type + Liter + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Type + Liter + Trim + Doors + Cylinder + Model + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Type + Liter + Trim + Cylinder + Model + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Type + Liter + Trim + Doors + Cylinder + Model + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Liter + Trim + Doors + Cylinder + Model + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Type + Liter + Trim  + Model + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Liter + Trim  + Model + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
kbb.glm <- glm(Price ~ Mileage + Make + Liter + Trim  + Model + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Liter + Trim + Model + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
summary(kbb.glm)
View(kbb)
View(kbb)
library(tidyverse)
library(ggfortify)
library(vroom)
library(car)
library(corrplot)
library(patchwork)
library(GGally)
library(xgboost)
library(Matrix)
library(MASS)
# read in dataset
kbb <- vroom("KBB.csv")
# Clean Data
# kbb$Trim <- gsub("Sedan|4D|Conv|2D|Hatchback|Coupe|Hback|wagon|Wagon", "", kbb$Trim)
# kbb$Trim <- trimws(kbb$Trim)
### EDA
# correlation matrix for numeric variables
corrplot::corrplot(cor(kbb[c(1,2,7,8,9,10,11,12)]))
# make boxplots for categorical variables
boxplot(Price ~ Make, data = kbb)
boxplot(Price ~ Model, data = kbb)
boxplot(Price ~ Trim, data = kbb)
boxplot(Price ~ Type, data = kbb)
ggplot(kbb, aes(x = Model, y = Price, fill = Make)) +
geom_boxplot() +
labs(title = "Boxplot of Price by Model and Make", x = "Model", y = "Price") +
theme_minimal() +
scale_fill_manual(values = rainbow(length(unique(kbb$Make))))  #
# fit a linear model
kbb.lm <- lm(Price ~ Mileage + Make + Type + Liter + Cylinder + Cruise + Sound + Leather + Mileage*Make, data = kbb)
print(summary(kbb.lm))
# trying some other stuff
test1 <- lm(Price ~ Mileage + Make + Type + Liter + Cruise + Sound + Leather + Mileage*Make, data = kbb)
summary(test1)
library(boot)
kbb.glm <- glm(Price ~ Mileage + Make + Type + Liter + Cylinder + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Liter + Trim + Model + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
summary(kbb.glm)
sqrt(cv_result$delta[1])
# variable selection with Cylinder
kbb.lm.select <- stepAIC(kbb.lm, direction = 'both', k = log(nrow(kbb)))
summary(kbb.lm.select)
# MSE
mean(summary(kbb.lm.select$residuals^2))
# variable selection without Cylinder
test1.select <-  stepAIC(test1, direction = "both", k = log(nrow(kbb)))
summary(test1.select)
# MSE
mean(summary(test1.select$residuals^2))
# save residuals and fitted values to original dataset
kbb <- kbb %>%
mutate(residuals = kbb.lm$residuals,
fitted = kbb.lm$fitted.values)
# use autoplot() function to check conditions
autoplot(kbb.lm)
# Shapiro-Wilk Test for normality of residuals
shapiro.test(kbb.lm$residuals)
# residuals vs predictor plots
resid_vs_Mileage <- ggplot(data = kbb) +
geom_point(mapping = aes(x = Mileage, y = residuals)) +
theme(aspect.ratio = 1)
resid_vs_Make <- ggplot(data = kbb) +
geom_point(mapping = aes(x = Make, y = residuals)) +
theme(aspect.ratio = 1)
resid_vs_Model <- ggplot(data = kbb) +
geom_point(mapping = aes(x = Model, y = residuals)) +
theme(aspect.ratio = 1)
resid_vs_Trim <- ggplot(data = kbb) +
geom_point(mapping = aes(x = Trim, y = residuals)) +
theme(aspect.ratio = 1)
resid_vs_Type <- ggplot(data = kbb) +
geom_point(mapping = aes(x = Type, y = residuals)) +
theme(aspect.ratio = 1)
resid_vs_Cylinder <- ggplot(data = kbb) +
geom_point(mapping = aes(x = Cylinder, y = residuals)) +
theme(aspect.ratio = 1)
resid_vs_Liter <- ggplot(data = kbb) +
geom_point(mapping = aes(x = Liter, y = residuals)) +
theme(aspect.ratio = 1)
resid_vs_Doors <- ggplot(data = kbb) +
geom_point(mapping = aes(x = Doors, y = residuals)) +
theme(aspect.ratio = 1)
resid_vs_Cruise <- ggplot(data = kbb) +
geom_point(mapping = aes(x = Cruise, y = residuals)) +
theme(aspect.ratio = 1)
resid_vs_Sound <- ggplot(data = kbb) +
geom_point(mapping = aes(x = Sound, y = residuals)) +
theme(aspect.ratio = 1)
resid_vs_Leather <- ggplot(data = kbb) +
geom_point(mapping = aes(x = Leather, y = residuals)) +
theme(aspect.ratio = 1)
(resid_vs_Mileage | resid_vs_Make | resid_vs_Model | resid_vs_Trim) /
(resid_vs_Type | resid_vs_Cylinder | resid_vs_Liter | resid_vs_Doors) /
(resid_vs_Cruise | resid_vs_Sound | resid_vs_Leather)
# model the interaction between Mileage and Make
test <- lm(Price ~ Mileage * Make + Type + Cylinder + Liter + Cruise + Sound + Leather, data = kbb)
summary(test)
# draw scatterplot just to see
ggplot(kbb, aes(x = Mileage, y = Price, color = Make)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
interaction_coefs <- sort(coef(test)[grepl(":", names(coef(test)))], decreasing = TRUE)
interaction_coefs
Makes <- coef(test)[grepl("^Make(S|C|P|B)", names(coef(test)))]
Mileage <- coef(test)[grepl("Mileage$", names(coef(test)))]
Make_Mileage <- coef(test)[grepl("Mileage:", names(coef(test)))]
# Models <- coef(test)[grepl("Model", names(coef(test)))]
# Trims <- coef(test)[grepl("Trim", names(coef(test)))]
Types <- coef(test)[grepl("Type", names(coef(test)))]
Cylinder <- coef(test)[grepl("Cylinder", names(coef(test)))]
Liter <- coef(test)[grepl("Liter", names(coef(test)))]
# Door <- coef(test)[grepl("Door", names(coef(test)))]
Cruise <- coef(test)[grepl("Cruise", names(coef(test)))]
Sound <- coef(test)[grepl("Sound", names(coef(test)))]
Leather <- coef(test)[grepl("Leather", names(coef(test)))]
######### THIS IS NOT ACCURATE YET, ADJUST FOR BASE CASES!!#####
Make_15000 <- Make_Mileage*15000 + Makes
paste("At 15000 Miles, the highest make resale value is a", names(Make_15000)[which.max(Make_15000)], Make_15000[which.max(Make_15000)])
paste("Highest Type:", names(Types)[which.max(Types)], Makes[which.max(Types)])
paste("More cylinders make resale value go", ifelse(Cylinder < 0, "down", "up"), "by", Cylinder, "per cylinder")
paste("More liters make resale value go", ifelse(Liter < 0, "down", "up"), "by", Liter, "per liter")
paste("Having cruise control makes resale value go", ifelse(Cruise < 0, "down", "up"), "by", Cruise)
paste("Having upgraded sound makes resale value go", ifelse(Sound < 0, "down", "up"), "by", Sound)
paste("Having a leather interior makes resale value go", ifelse(Leather < 0, "down", "up"), "by", Leather)
# Convert categorical variables to factors
kbb$Make <- as.factor(kbb$Make)
kbb$Model <- as.factor(kbb$Model)
kbb$Trim <- as.factor(kbb$Trim)
kbb$Type <- as.factor(kbb$Type)
# Prepare the target variable (resale price)
y <- kbb$Price
# Create a sparse matrix for the feature set (X) by converting categorical variables to dummy variables
X <- sparse.model.matrix(Price ~ Mileage + Make + Model + Trim + Type + Cylinder + Liter + Doors + Cruise + Sound + Leather - 1, data = kbb)
# Split the data into training and testing sets (optional)
set.seed(123)
train_indices <- sample(1:nrow(kbb), 0.8 * nrow(kbb))  # 80% for training
X_train <- X[train_indices, ]
X_test <- X[-train_indices, ]
y_train <- y[train_indices]
y_test <- y[-train_indices]
# Convert data into DMatrix format for XGBoost
dtrain <- xgb.DMatrix(data = X_train, label = y_train)
dtest <- xgb.DMatrix(data = X_test, label = y_test)
# Set XGBoost parameters
params <- list(
objective = "reg:squarederror",  # For regression
booster = "gbtree",              # Use tree-based boosting
eta = 0.1,                       # Learning rate
max_depth = 6,                   # Maximum depth of a tree
subsample = 0.8,                 # Fraction of data to be used for each tree
colsample_bytree = 0.8           # Fraction of features to be used for each tree
)
# Train the model
xgb_model <- xgb.train(
params = params,
data = dtrain,
nrounds = 100,           # Number of boosting rounds (trees)
watchlist = list(train = dtrain, test = dtest),  # To evaluate on both training and test sets
early_stopping_rounds = 10,  # Stop early if no improvement
print_every_n = 10  # Print progress every 10 rounds
)
# Make predictions on the test set
y_pred <- predict(xgb_model, newdata = dtest)
# View the first few predictions
head(y_pred)
# Calculate RMSE
rmse <- sqrt(mean((y_pred - y_test)^2))
print(paste("RMSE:", rmse))
# Create new data for prediction (e.g., with Mileage = 15000)
new_data <- kbb
new_data$Mileage <- 15000
# Convert new_data into a sparse matrix for prediction
X_new <- sparse.model.matrix(Price ~ Mileage + Make + Model + Trim + Type + Cylinder + Liter + Doors + Cruise + Sound + Leather - 1, data = new_data)
# Predict resale price at 15,000 miles
y_pred_15000 <- predict(xgb_model, newdata = X_new)
# Add predictions to new_data
new_data$PredictedPrice <- y_pred_15000
# View the top 10 cars with the highest resale values at 15,000 miles
head(new_data[order(-new_data$PredictedPrice), ], 10)
# view just the highest resale value car at 15,000 miles
best_car <- new_data[which.max(new_data$PredictedPrice), ]
print(best_car)
predict(kbb.lm,
newdata = data.frame(Make = "Cadillac",
Model = "CTS",
Doors = 4,
Trim = "Sedan 4D",
Type = "Sedan",
Mileage = 17000,
Cylinder = 6,
Liter = 2.8,
Cruise = 1,
Sound = 1,
Leather = 1)
)
View(kbb)
kbb %>% select(-residuals, -fitted)
kbb <- kbb %>% select(-residuals, -fitted)
library(tidyverse)
library(ggfortify)
library(vroom)
library(car)
library(corrplot)
library(patchwork)
library(GGally)
library(xgboost)
library(Matrix)
library(MASS)
# read in dataset
kbb <- vroom("KBB.csv")
# Clean Data
# kbb$Trim <- gsub("Sedan|4D|Conv|2D|Hatchback|Coupe|Hback|wagon|Wagon", "", kbb$Trim)
# kbb$Trim <- trimws(kbb$Trim)
### EDA
# correlation matrix for numeric variables
corrplot::corrplot(cor(kbb[c(1,2,7,8,9,10,11,12)]))
# make boxplots for categorical variables
boxplot(Price ~ Make, data = kbb)
boxplot(Price ~ Model, data = kbb)
boxplot(Price ~ Trim, data = kbb)
boxplot(Price ~ Type, data = kbb)
ggplot(kbb, aes(x = Model, y = Price, fill = Make)) +
geom_boxplot() +
labs(title = "Boxplot of Price by Model and Make", x = "Model", y = "Price") +
theme_minimal() +
scale_fill_manual(values = rainbow(length(unique(kbb$Make))))  #
# fit a linear model
kbb.lm <- lm(Price ~ Mileage + Make + Type + Liter + Cylinder + Cruise + Sound + Leather + Mileage*Make, data = kbb)
print(summary(kbb.lm))
# trying some other stuff
test1 <- lm(Price ~ Mileage + Make + Type + Liter + Cruise + Sound + Leather + Mileage*Make, data = kbb)
summary(test1)
library(boot)
kbb.glm <- glm(Price ~ Mileage + Make + Type + Liter + Cylinder + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Liter + Trim + Model + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
kbb <- kbb %>% select(-residuals, -fitted)
kbb <- kbb %>% dplyr::select(-residuals, -fitted)
View(kbb)
ggplot(kbb, aes(x = Mileage, y = Price, color = Make)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
```{r, echo = FALSE, warning = FALSE}
ggplot(kbb, aes(x = Mileage, y = Price, color = Make)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
```{r, echo = FALSE, message = FALSE}
ggplot(kbb, aes(x = Mileage, y = Price, color = Make)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
Makes <- coef(test)[grepl("^Make(S|C|P|B)", names(coef(test)))]
Makes <- c(Makes, c(Buick = 0))
Mileage <- coef(test)[grepl("Mileage$", names(coef(test)))]
Mileage <- c(Mileage, c(Buick = 0))
Make_Mileage <- coef(test)[grepl("Mileage:", names(coef(test)))]
Make_Mileage <- c(Make_Mileage, Mileage:Buick = 0)
Make_Mileage <- c(Make_Mileage, `Mileage:Buick` = 0)
Makes
Makes <- c(Makes, c(MakeBuick = 0))
Mileage <- coef(test)[grepl("Mileage$", names(coef(test)))]
Mileage <- c(Mileage, c(MileageBuick = 0))
Make_Mileage <- coef(test)[grepl("Mileage:", names(coef(test)))]
Make_Mileage <- c(Make_Mileage, `Mileage:Buick` = 0)
Makes <- coef(test)[grepl("^Make(S|C|P|B)", names(coef(test)))]
Makes <- c(Makes, c(MakeBuick = 0))
Mileage <- coef(test)[grepl("Mileage$", names(coef(test)))]
Mileage <- c(Mileage, c(MileageBuick = 0))
Make_Mileage <- coef(test)[grepl("Mileage:", names(coef(test)))]
Make_Mileage <- c(Make_Mileage, `Mileage:Buick` = 0)
Makes
Mileage
MakeMileage
Make_Mileage
# Models <- coef(test)[grepl("Model", names(coef(test)))]
# Trims <- coef(test)[grepl("Trim", names(coef(test)))]
Types <- coef(test)[grepl("Type", names(coef(test)))]
Cylinder <- coef(test)[grepl("Cylinder", names(coef(test)))]
Liter <- coef(test)[grepl("Liter", names(coef(test)))]
# Door <- coef(test)[grepl("Door", names(coef(test)))]
Cruise <- coef(test)[grepl("Cruise", names(coef(test)))]
Sound <- coef(test)[grepl("Sound", names(coef(test)))]
Leather <- coef(test)[grepl("Leather", names(coef(test)))]
######### THIS IS NOT ACCURATE YET, ADJUST FOR BASE CASES!!#####
Make_15000 <- Make_Mileage*15000 + Makes
paste("At 15000 Miles, the highest make resale value is a", names(Make_15000)[which.max(Make_15000)], Make_15000[which.max(Make_15000)])
paste("Highest Type:", names(Types)[which.max(Types)], Makes[which.max(Types)])
View(kbb)
Types <- c(Types, Convertible = 0)
paste("Highest Type:", names(Types)[which.max(Types)], Makes[which.max(Types)])
Types
Types <- c(Types, TypeConvertible = 0)
paste("Highest Type:", names(Types)[which.max(Types)], Makes[which.max(Types)])
Types
library(tidyverse)
library(ggfortify)
library(vroom)
library(car)
library(corrplot)
library(patchwork)
library(GGally)
library(xgboost)
library(Matrix)
library(MASS)
# read in dataset
kbb <- vroom("KBB.csv")
# Clean Data
# kbb$Trim <- gsub("Sedan|4D|Conv|2D|Hatchback|Coupe|Hback|wagon|Wagon", "", kbb$Trim)
# kbb$Trim <- trimws(kbb$Trim)
### EDA
# correlation matrix for numeric variables
corrplot::corrplot(cor(kbb[c(1,2,7,8,9,10,11,12)]))
# make boxplots for categorical variables
boxplot(Price ~ Make, data = kbb)
boxplot(Price ~ Model, data = kbb)
boxplot(Price ~ Trim, data = kbb)
boxplot(Price ~ Type, data = kbb)
ggplot(kbb, aes(x = Model, y = Price, fill = Make)) +
geom_boxplot() +
labs(title = "Boxplot of Price by Model and Make", x = "Model", y = "Price") +
theme_minimal() +
scale_fill_manual(values = rainbow(length(unique(kbb$Make))))  #
ggplot(kbb, aes(x = Mileage, y = Price, color = Make)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
# fit a linear model
kbb.lm <- lm(Price ~ Mileage + Make + Type + Liter + Cylinder + Cruise + Sound + Leather + Mileage*Make, data = kbb)
print(summary(kbb.lm))
# trying some other stuff
test1 <- lm(Price ~ Mileage + Make + Type + Liter + Cruise + Sound + Leather + Mileage*Make, data = kbb)
summary(test1)
library(boot)
kbb.glm <- glm(Price ~ Mileage + Make + Type + Liter + Cylinder + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Liter + Trim + Model + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
kbb <- kbb %>% dplyr::select(-residuals, -fitted)
library(tidyverse)
library(ggfortify)
library(vroom)
library(car)
library(corrplot)
library(patchwork)
library(GGally)
library(xgboost)
library(Matrix)
library(MASS)
# read in dataset
kbb <- vroom("KBB.csv")
# Clean Data
# kbb$Trim <- gsub("Sedan|4D|Conv|2D|Hatchback|Coupe|Hback|wagon|Wagon", "", kbb$Trim)
# kbb$Trim <- trimws(kbb$Trim)
### EDA
# correlation matrix for numeric variables
corrplot::corrplot(cor(kbb[c(1,2,7,8,9,10,11,12)]))
# make boxplots for categorical variables
boxplot(Price ~ Make, data = kbb)
boxplot(Price ~ Model, data = kbb)
boxplot(Price ~ Trim, data = kbb)
boxplot(Price ~ Type, data = kbb)
ggplot(kbb, aes(x = Model, y = Price, fill = Make)) +
geom_boxplot() +
labs(title = "Boxplot of Price by Model and Make", x = "Model", y = "Price") +
theme_minimal() +
scale_fill_manual(values = rainbow(length(unique(kbb$Make))))  #
ggplot(kbb, aes(x = Mileage, y = Price, color = Make)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
# fit a linear model
kbb.lm <- lm(Price ~ Mileage + Make + Type + Liter + Cylinder + Cruise + Sound + Leather + Mileage*Make, data = kbb)
print(summary(kbb.lm))
# trying some other stuff
test1 <- lm(Price ~ Mileage + Make + Type + Liter + Cruise + Sound + Leather + Mileage*Make, data = kbb)
summary(test1)
library(boot)
kbb.glm <- glm(Price ~ Mileage + Make + Type + Liter + Cylinder + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
sqrt(cv_result$delta[1])
kbb.glm <- glm(Price ~ Mileage + Make + Liter + Trim + Model + Cruise + Sound + Leather + Mileage*Make, data = kbb, family = gaussian)
cv_result <- cv.glm(kbb, kbb.glm, K = 10)  # K is the number of folds, e.g., 10-fold CV
kbb <- kbb %>% dplyr::select(-residuals, -fitted)
clear
q()
tinytex::install_tinytex()
ls
ls
q()
reticulate::repl_python()
Sys.setenv(RETICULATE_PYTHON = "/Users/hawkety77/School Projects/.venv/bin/python")
reticulate::repl_python()
reticulate::repl_python()
Sys.setenv(RETICULATE_PYTHON = "/usr/local/bin/python3")
reticulate::repl_python()
Sys.setenv(RETICULATE_PYTHON = "/usr/local/bin/python3")
Sys.setenv(RETICULATE_MINICONDA_ENABLED = "FALSE")
reticulate::repl_python()
library(reticulate)
use_python("/usr/local/bin/python3", required = TRUE)
reticulate::repl_python()
#| echo: false
2 * 2
library(reticulate)
use_python("/usr/local/bin/python3", required = TRUE)
library(reticulate)
use_python("/usr/local/bin/python3", required = TRUE)
repl_python()
reticulate::repl_python()
# Check the current Python environment
reticulate::py_config()
# Install pandas in the current environment
reticulate::py_install("pandas")
# read in the data
water = read.table('AgricultureWater.txt',header=T)
setwd("~/School Projects/STAT536/IC3")
# read in the data
water = read.table('AgricultureWater.txt',header=T)
# Polynomial regression
library(splines)
## Splines (and basis function expansions)
# To use splines, you will need the `splines` library in R.
# All basis function expansions are done within R formulas (so I hope you are comfortable with them by now).
# For example, to fit a B-spline you would specify the formula `lm(y~bs(x, df=))` where `x` is the
# variable you want a spline in.
# - `poly(var_name, degree=)` - creates a `degree` polynomial in `var_name`
model1 = lm(swc~poly(cwsi, degree = 2), data = water)
plot(water$cwsi, water$swc)
lines(water$cwsi[order(water$cwsi)], model1$fitted.values[order(water$cwsi)])
# - `bs(var_name, df=, degree=, knots=)` - creates a `degree` B-spline in the variable `var_name` with `df` degrees of freedom.  Altneratively, you can use the `knots` argument to specify where the knots are put.  If you only give the `df` then it will put the knots equally spaced.
model2 = lm(swc~bs(cwsi, df = 5, degree = 8, knots = 100), data = water)
plot(water$cwsi, water$swc)
lines(water$cwsi[order(water$cwsi)], model2$fitted.values[order(water$cwsi)])
# - `ns(var_name, df=, degree=, knots=)` - create a `degree` natural spline in the variable `var_name` with `df` degrees of freedom or `knots`.
# model3 = lm(swc~ns(cwsi, df = 5, knots = 100), data = water)
# plot(water$cwsi, water$swc)
# lines(water$cwsi[order(water$cwsi)], model3$fitted.values[order(water$cwsi)])
# - `I()` - this is for special use within formulas where you can put any function you want.  For example, if I put `y~I(x>10)` it will set up a step function at the point 10.  Likewise, `y~I(x^2)` will put a squared term for `x` (although `poly()` above is a better way to do polynomial regression).  So, anytime you alter a variable within a formula, make sure you use `I()`.
# LOESS
model_loess = loess(swc ~ cwsi, data = water, span = .75, degree = 1)
plot(water$cwsi, water$swc)
lines(water$cwsi[order(water$cwsi)], model_loess$fitted[order(water$cwsi)], col = "blue")
setwd("~/School Projects/STAT536/STAT536HW3")
